package handler

import (
	"context"
	"net/http"
	"strconv"
	"time"

	"github.com/Financial-Partner/server/internal/contextutil"
	"github.com/Financial-Partner/server/internal/entities"
	"github.com/Financial-Partner/server/internal/interfaces/http/dto"
	httperror "github.com/Financial-Partner/server/internal/interfaces/http/error"
	responde "github.com/Financial-Partner/server/internal/interfaces/http/respond"
)

//go:generate mockgen -source=report.go -destination=report_mock.go -package=handler

type ReportService interface {
	GetReport(ctx context.Context, userID string, startTime time.Time, endTime time.Time, reportType string) (*entities.Report, error)
	GetReportSummary(ctx context.Context, userID string) (*entities.ReportSummary, error)
}

// @Summary Get report
// @Description Get report for a user
// @Tags reports
// @Accept json
// @Produce json
// @Param Authorization header string true "Bearer {token}" default
// @Param type query string true "Type of report (summary or detailed)"
// @Param start query int64 false "Start time as Unix timestamp (seconds since epoch)"
// @Param end query int64 false "End time as Unix timestamp (seconds since epoch)"
// @Success 200 {object} dto.ReportResponse
// @Failure 400 {object} dto.ErrorResponse
// @Failure 401 {object} dto.ErrorResponse
// @Failure 500 {object} dto.ErrorResponse
// @Router /reports/finance [get]
func (h *Handler) GetReport(w http.ResponseWriter, r *http.Request) {
	// Parse query parameters
	reportType := r.URL.Query().Get("type")
	start := r.URL.Query().Get("start")
	end := r.URL.Query().Get("end")

	var startDate, endDate time.Time
	var err error
	if start != "" {
		startTimestamp, err := strconv.ParseInt(start, 10, 64) // Parse Unix timestamp
		if err != nil {
			h.log.Warnf("Invalid start timestamp format. Use a valid Unix timestamp.")
			responde.WithError(w, r, h.log, err, httperror.ErrInvalidParameter, http.StatusBadRequest)
			return
		}
		startDate = time.Unix(startTimestamp, 0).UTC() // Convert to time.Time in UTC
	}

	if end != "" {
		endTimestamp, err := strconv.ParseInt(end, 10, 64) // Parse Unix timestamp
		if err != nil {
			h.log.Warnf("Invalid end timestamp format. Use a valid Unix timestamp.")
			responde.WithError(w, r, h.log, err, httperror.ErrInvalidParameter, http.StatusBadRequest)
			return
		}
		endDate = time.Unix(endTimestamp, 0).UTC() // Convert to time.Time in UTC
	}

	userID, ok := contextutil.GetUserID(r.Context())
	if !ok {
		h.log.Warnf("failed to get user ID from context")
		responde.WithError(w, r, h.log, nil, httperror.ErrUnauthorized, http.StatusUnauthorized)
		return
	}

	report, err := h.reportService.GetReport(r.Context(), userID, startDate, endDate, reportType)
	if err != nil {
		h.log.Errorf("failed to get report")
		responde.WithError(w, r, h.log, err, httperror.ErrFailedToGetReport, http.StatusInternalServerError)
		return
	}

	resp := dto.ReportResponse{
		Revenue:     report.Revenue,
		Expenses:    report.Expenses,
		NetProfit:   report.NetProfit,
		Categories:  report.Categories,
		Amounts:     report.Amounts,
		Percentages: report.Percentages,
	}

	responde.WithJSON(w, r, resp, http.StatusOK)
}

// @Summary Get report summary
// @Description Get report summary generated by AI for a user
// @Tags reports
// @Accept json
// @Produce json
// @Param Authorization header string true "Bearer {token}" default
// @Success 200 {object} dto.ReportSummaryResponse
// @Failure 401 {object} dto.ErrorResponse
// @Failure 500 {object} dto.ErrorResponse
// @Router /reports/analysis [get]
func (h *Handler) GetReportSummary(w http.ResponseWriter, r *http.Request) {
	userID, ok := contextutil.GetUserID(r.Context())
	if !ok {
		h.log.Warnf("failed to get user ID from context")
		responde.WithError(w, r, h.log, nil, httperror.ErrUnauthorized, http.StatusUnauthorized)
		return
	}

	reportSummary, err := h.reportService.GetReportSummary(r.Context(), userID)
	if err != nil {
		h.log.Errorf("failed to get report summary")
		responde.WithError(w, r, h.log, err, httperror.ErrFailedToGetReportSummary, http.StatusInternalServerError)
		return
	}

	resp := dto.ReportSummaryResponse{
		Summary: reportSummary.Summary,
	}

	responde.WithJSON(w, r, resp, http.StatusOK)
}
